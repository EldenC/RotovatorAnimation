<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Rotovator Sky Hook Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        canvas { display: block; }
        .overlay { position: absolute; color: white; font-family: Arial; font-size: 14px; }
        #time { top: 10px; left: 10px; }
        #controls { bottom: 10px; left: 10px; }
        #displays { top: 10px; right: 10px; background: rgba(0,0,0,0.5); padding: 5px; }
        #orbitsTable { top: 50px; left: 10px; background: rgba(0,0,0,0.5); padding: 10px; display: none; }
        #intro { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 30px; color: white; animation: fade 2s forwards; }
        @keyframes fade { to { opacity: 0; } }
        .color-square { width: 20px; height: 20px; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="time" class="overlay"></div>
    <div id="controls" class="overlay">
        Altitude M (km): <input type="range" id="h_m_slider" min="5.0106352941" max="8.2940496401" step="0.03" value="5.3936275464"><span id="h_m_val">220</span><br>
        RPM: <input type="range" id="rpm_slider" min="-4.605170186" max="0.0" step="0.06" value="-1.70"><span id="rpm_val">0.20</span><br>
        Arm radius (km): <input type="range" id="r_arm_slider" min="2.302585093" max="6.907755279" step="0.05" value="5.0106352941"><span id="r_arm_val">150</span><br>
        Sim speed mult: <input type="range" id="mult_slider" min="-6.907755279" max="6.907755279" step="0.14" value="3.6888794541"><span id="mult_val">40</span><br>
        D (km): <input type="range" id="d_slider" min="-1000" max="1000" step="1" value="114"><span id="d_val">114</span><br>
        Mass at A (t): <input type="range" id="m_a_slider" min="-6.907755279" max="9.6158054801" step="0.16" value="7.1708884785"><span id="m_a_val">1300</span><br>
        Mass at B (t): <input type="range" id="m_b_slider" min="-6.907755279" max="9.6158054801" step="0.16" value="7.1708884785"><span id="m_b_val">1300</span><br>
        <button id="pause">Pause</button>
        <input type="text" id="hours" size="3" value="0"> hours
        <input type="text" id="mins" size="3" value="0.1"> min
        <button id="forward">Forward</button>
        <button id="reverse">Reverse</button><br>
        Zoom center: <select id="zoom_center">
            <option value="rotovator" selected>Rotovator</option>
            <option value="earth">Earth</option>
            <option value="moon">Moon</option>
            <option value="midpoint">Midpoint Earth-Moon</option>
        </select><br>
        <button id="orbits_toggle">Orbits</button>
    </div>
    <div id="displays" class="overlay"></div>
    <div id="orbitsTable" class="overlay">
        <table id="orbits_table"></table>
        <button id="all">All</button>
        <button id="none">None</button>
        <button id="close">Close</button>
    </div>
    <div id="intro">Written by Grok and Elden Crom</div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const timeDiv = document.getElementById('time');
        const displaysDiv = document.getElementById('displays');
        const orbitsTableDiv = document.getElementById('orbitsTable');
        const orbitsTable = document.getElementById('orbits_table');
        const introDiv = document.getElementById('intro');

        // Constants
        const G = 6.67430e-11;
        const M_earth = 5.972e24;
        const GM_earth = G * M_earth;
        const R_earth = 6371000;
        const M_moon = 7.342e22;
        const GM_moon = G * M_moon;
        const R_moon = 1737000;
        const D_moon = 384400000;
        const sidereal_day = 86164;
        const moon_period = 27.321661 * 86400;
        const g0 = 9.81;
        const arrow_length = D_moon / 10;
        const mars_angle = Math.PI / 2 + 38 * Math.PI / 180;
        const ship_size = 50000;
        const arrow_size = 1000000; // for trajectory arrows

        // Simulation variables
        let sim_time = 0;
        let current_date = new Date('2025-08-30T00:00:00Z');
        let paused = false;
        let last_frame = performance.now();
        let start_time = performance.now() / 1000;
        let scale = 1;
        let center = {x: 0, y: 0};
        let visibility = {};
        let info_overlays = [];

        // Sliders and values
        let h_m = 220 * 1000;
        let rpm = 0.20;
        let r_arm = 150 * 1000;
        let mult = 40;
        let d = 114 * 1000;
        let m_a = 1300 * 1000;
        let m_b = 1300 * 1000;

        // Orbits, trajectories, info
        const orbits_list = [
            {name: 'LLEO', h: 65.3*1000, v: 7870, color: '#ff5000'},
            {name: 'ISS', h: 400*1000, v: 7670, color: '#00ffff'},
            {name: 'Hubble', h: 530*1000, v: 7600, color: '#0000ff'},
            {name: 'Starlink', h: 550*1000, v: 7590, color: '#ffff00'},
            {name: 'Iridium', h: 780*1000, v: 7470, color: '#ff00ff'},
            {name: 'GPS', h: 20200*1000, v: 3870, color: '#00ffff'},
            {name: 'Geostationary', h: 35786*1000, v: 3080, color: '#ff8000'},
            {name: 'Moon', h: 384400*1000, v: 1010, color: '#808080'},
        ];
        const trajectories_list = [
            {name: 'A release', point: 'A', color: '#ffffff'},
            {name: 'B release', point: 'B', color: '#cccccc'},
            {name: 'D release', point: 'D', color: '#999999'},
        ];
        const info_list = [
            {name: 'Info ?A?', point: 'A', type: 'info'},
            {name: 'Info ?B?', point: 'B', type: 'info'},
            {name: 'Info ?Cm?', point: 'Cm', type: 'info'},
            {name: 'Info ?D?', point: 'D', type: 'info'},
        ];
        const all_items = [...orbits_list.map(o => ({...o, type: 'orbit'})), ...trajectories_list.map(t => ({...t, type: 'trajectory'})), ...info_list];

        // Initialize visibility
        //all_items.forEach(item => visibility[item.name] = true);
        all_items.forEach(item => visibility[item.name] = false);
        visibility["LLEO"] = true;
        visibility["ISS"] = true;
        visibility["GPS"] = true;
        visibility["Geostationary"] = true;
        visibility["Moon"] = true;
        visibility["A release"] = true;
        visibility["B release"] = true;
        visibility["D release"] = true;

        // Build table
        let tr = document.createElement('tr');
        tr.innerHTML = '<th>Item</th><th>Color</th><th>Visible</th><th>Orbits <br> Count</th><th>Minutes <br> per <br>  Arrow </th>';
        orbitsTable.appendChild(tr);
        all_items.forEach(item => {
            tr = document.createElement('tr');
            let color_td = item.color ? `<td><div class="color-square" style="background:${item.color};"></div></td>` : '<td></td>';
            //let visible_td = `<td><input type="checkbox" data-name="${item.name}" checked></td>`;
            let visible_td = `<td><input type="checkbox" data-name="${item.name}" ${visibility[item.name] ? 'checked' : ''}></td>`;
            let orbits_td = item.type === 'trajectory' ? `<td><input type="text" id="orbits_${item.name}" value="1" size="3"></td>` : '<td></td>';
            let arrow_td = item.type === 'trajectory' ? `<td><input type="text" id="arrow_${item.name}" value="20" size="3"></td>` : '<td></td>';
            tr.innerHTML = `<td>${item.name}</td>${color_td}${visible_td}${orbits_td}${arrow_td}`;
            orbitsTable.appendChild(tr);
        });
        //visibility["LLEO"].visible_td = true;
        //item => visibility["ISS"] = true;
        //item => visibility["Geostationary"] = true;
        //item => visibility["Moon"] = true;
        //item => visibility["A release"] = true;
        //item => visibility["B release"] = true;
        //item => visibility["D release"] = true;


        // Continents same as before
        const continents = [
            // ... same as previous
            [
                {lat: 80, lon: -60},
                {lat: 70, lon: -140},
                {lat: 50, lon: -130},
                {lat: 30, lon: -120},
                {lat: 20, lon: -100},
                {lat: 30, lon: -75},
                {lat: 50, lon: -60},
                {lat: 70, lon: -50},
                {lat: 80, lon: -60},
            ],
            [
                {lat: 70, lon: -10},
                {lat: 60, lon: -5},
                {lat: 40, lon: 5},
                {lat: 35, lon: 30},
                {lat: 50, lon: 40},
                {lat: 60, lon: 30},
                {lat: 70, lon: 20},
                {lat: 70, lon: -10},
            ],
            [
                {lat: 70, lon: 40},
                {lat: 80, lon: 100},
                {lat: 70, lon: 160},
                {lat: 50, lon: 140},
                {lat: 30, lon: 120},
                {lat: 20, lon: 70},
                {lat: 40, lon: 50},
                {lat: 70, lon: 40},
            ],
            [
                {lat: 35, lon: -5},
                {lat: 30, lon: 35},
                {lat: 15, lon: 45},
                {lat: 10, lon: 20},
                {lat: 15, lon: -15},
                {lat: 35, lon: -5},
            ],
            [
                {lat: 80, lon: -40},
                {lat: 75, lon: -60},
                {lat: 70, lon: -50},
                {lat: 70, lon: -20},
                {lat: 75, lon: -20},
                {lat: 80, lon: -40},
            ]
        ];

        const boca_lon = -97;
        const cape_lon = -80.5;

        // Event listeners same as before
        document.getElementById('pause').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('pause').textContent = paused ? 'Resume' : 'Pause';
        });
        document.getElementById('forward').addEventListener('click', () => {
            const h = parseFloat(document.getElementById('hours').value) || 0;
            const m = parseFloat(document.getElementById('mins').value) || 0;
            sim_time += h * 3600 + m * 60;
        });
        document.getElementById('reverse').addEventListener('click', () => {
            const h = parseFloat(document.getElementById('hours').value) || 0;
            const m = parseFloat(document.getElementById('mins').value) || 0;
            sim_time -= h * 3600 + m * 60;
        });
        document.getElementById('orbits_toggle').addEventListener('click', () => {
            orbitsTableDiv.style.display = orbitsTableDiv.style.display === 'none' ? 'block' : 'none';
        });
        document.getElementById('all').addEventListener('click', () => {
            all_items.forEach(item => visibility[item.name] = true);
            orbitsTable.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true);
        });
        document.getElementById('none').addEventListener('click', () => {
            all_items.forEach(item => visibility[item.name] = false);
            orbitsTable.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
        });
        document.getElementById('close').addEventListener('click', () => {
            orbitsTableDiv.style.display = 'none';
        });
        orbitsTable.addEventListener('change', e => {
            if (e.target.type === 'checkbox') {
                visibility[e.target.dataset.name] = e.target.checked;
            }
        });
        orbitsTableDiv.style.display = 'block';

        // Sliders
        const sliders = {
            h_m: {slider: document.getElementById('h_m_slider'), val: document.getElementById('h_m_val'), update: v => h_m = Math.exp(v) * 1000, format: v => Math.round(Math.exp(v)).toString()},
            rpm: {slider: document.getElementById('rpm_slider'), val: document.getElementById('rpm_val'), update: v => rpm = Math.exp(v), format: v => Math.exp(v).toFixed(2)},
            r_arm: {slider: document.getElementById('r_arm_slider'), val: document.getElementById('r_arm_val'), update: v => r_arm = Math.exp(v) * 1000, format: v => Math.round(Math.exp(v)).toString()},
            mult: {slider: document.getElementById('mult_slider'), val: document.getElementById('mult_val'), update: v => mult = Math.exp(v), format: v => Math.exp(v).toFixed(3)},
            d: {slider: document.getElementById('d_slider'), val: document.getElementById('d_val'), update: v => d = parseFloat(v) * 1000, format: v => parseFloat(v).toFixed(0)},
            m_a: {slider: document.getElementById('m_a_slider'), val: document.getElementById('m_a_val'), update: v => m_a = Math.exp(v) * 1000, format: v => Math.round(Math.exp(v)).toString()},
            m_b: {slider: document.getElementById('m_b_slider'), val: document.getElementById('m_b_val'), update: v => m_b = Math.exp(v) * 1000, format: v => Math.round(Math.exp(v)).toString()},
        };
        Object.values(sliders).forEach(s => {
            s.slider.addEventListener('input', e => {
                const v = parseFloat(e.target.value);
                s.update(v);
                s.val.textContent = s.format(v);
                if (s === sliders.r_arm) {
                    sliders.d.slider.min = -Math.exp(v);
                    sliders.d.slider.max = Math.exp(v);
                    if (Math.abs(d / 1000) > Math.exp(v)) {
                        d = Math.sign(d) * Math.exp(v) * 1000;
                        sliders.d.slider.value = d / 1000;
                        sliders.d.val.textContent = (d / 1000).toFixed(0);
                    }
                }
            });
        });

        // Mouse wheel
        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            const factor = e.deltaY < 0 ? 1.1 : 0.909;
            scale *= factor;
        });

        // Resize
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // Compute trajectory
        function computeTrajectory(pos, vel, orbits_count, arrow_minutes) {
            const dt = 10;
            const max_steps = 100000;
            const arrow_time = arrow_minutes * 60;
            const points = [{x: pos.x, y: pos.y, vx: vel.x, vy: vel.y}];
            let current_pos = {x: pos.x, y: pos.y};
            let current_vel = {x: vel.x, y: vel.y};
            let collided = false;
            let escaped = false;
            let collision_pos = null;
            let collision_vel = null;
            let total_angle = 0;
            let old_theta = Math.atan2(current_pos.y, current_pos.x);
            let energy = current_vel.x**2 / 2 + current_vel.y**2 / 2 - GM_earth / Math.sqrt(current_pos.x**2 + current_pos.y**2);
            let is_orbit = energy < 0;
            for (let step = 0; step < max_steps; step++) {
                const r = Math.sqrt(current_pos.x**2 + current_pos.y**2);
                if (r < R_earth) {
                    collided = true;
                    collision_pos = {x: current_pos.x, y: current_pos.y};
                    collision_vel = {vx: current_vel.x, vy: current_vel.y};
                    break;
                }
                const rm = Math.sqrt((current_pos.x - moon_pos.x)**2 + (current_pos.y - moon_pos.y)**2);
                if (r > 2 * D_moon) {
                    escaped = true;
                }
                const acc_earth_x = -GM_earth * current_pos.x / r**3;
                const acc_earth_y = -GM_earth * current_pos.y / r**3;
                const acc_moon_x = -GM_moon * (current_pos.x - moon_pos.x) / rm**3;
                const acc_moon_y = -GM_moon * (current_pos.y - moon_pos.y) / rm**3;
                current_vel.x += (acc_earth_x + acc_moon_x) * dt;
                current_vel.y += (acc_earth_y + acc_moon_y) * dt;
                current_pos.x += current_vel.x * dt;
                current_pos.y += current_vel.y * dt;
                points.push({x: current_pos.x, y: current_pos.y, vx: current_vel.x, vy: current_vel.y});
                let new_theta = Math.atan2(current_pos.y, current_pos.x);
                let delta = new_theta - old_theta;
                if (delta > Math.PI) delta -= 2 * Math.PI;
                if (delta < -Math.PI) delta += 2 * Math.PI;
                total_angle += delta;
                old_theta = new_theta;
                if (is_orbit && Math.abs(total_angle) > 2 * Math.PI * orbits_count) break;
                if (escaped) break;
            }
            let color = collided ? 'red' : (escaped ? 'lime' : 'blue');
            return {points, color, collided, collision_pos, collision_vel, arrow_time};
        }

        // Draw arrow
        function drawArrow(from, to, size = arrow_size) {
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            const len = Math.sqrt(dx**2 + dy**2);
            if (len === 0) return;
            const udx = dx / len;
            const udy = dy / len;
            const head_x = to.x - size * udx;
            const head_y = to.y - size * udy;
            ctx.beginPath();
            ctx.moveTo(to.x, to.y);
            ctx.lineTo(head_x - size * udy / 2, head_y + size * udx / 2);
            ctx.moveTo(to.x, to.y);
            ctx.lineTo(head_x + size * udy / 2, head_y - size * udx / 2);
            ctx.stroke();
        }

        // Arched text
        function drawArchedText(text, x, y, radius) {
            ctx.save();
            ctx.translate(x, y);
            const angle = Math.PI / 2;
            const step = angle / (text.length - 1);
            for (let i = 0; i < text.length; i++) {
                ctx.save();
                ctx.rotate(-angle / 2 + i * step);
                ctx.translate(0, -radius);
                ctx.rotate(Math.PI);
                ctx.fillText(text[i], 0, 0);
                ctx.restore();
            }
            ctx.restore();
        }

        // Get screen pos
        function getScreenPos(world_x, world_y) {
            const sx = (world_x - center.x) * scale + canvas.width / 2;
            const sy = (world_y - center.y) * scale + canvas.height / 2;
            return {sx, sy};
        }

        // Animation
        let moon_pos, moon_vel;
        function animate(now) {
            const delta = (now - last_frame) / 1000;
            last_frame = now;
            if (!paused) sim_time += delta * mult;
            const date = new Date(current_date.getTime() + sim_time * 1000);
            timeDiv.textContent = date.toUTCString();

            // Positions
            const moon_angle = 2 * Math.PI * sim_time / moon_period;
            moon_pos = {x: D_moon * Math.cos(moon_angle), y: D_moon * Math.sin(moon_angle)};
            moon_vel = {x: - (2 * Math.PI * D_moon / moon_period) * Math.sin(moon_angle), y: (2 * Math.PI * D_moon / moon_period) * Math.cos(moon_angle)};

            const r_cm = R_earth + h_m;
            const omega_orb = Math.sqrt(GM_earth / r_cm**3);
            const theta_orb = omega_orb * sim_time;
            const pos_cm = {x: r_cm * Math.cos(theta_orb), y: r_cm * Math.sin(theta_orb)};
            const vel_cm = {x: - r_cm * omega_orb * Math.sin(theta_orb), y: r_cm * omega_orb * Math.cos(theta_orb)};

            const omega_rot = rpm * 2 * Math.PI / 60;
            const theta_rot = omega_rot * sim_time;
            const unit_x = Math.cos(theta_rot);
            const unit_y = Math.sin(theta_rot);
            const deltaP = (m_a - m_b) / (m_a + m_b);
            const pos_m = {x: pos_cm.x - deltaP * r_arm * unit_x, y: pos_cm.y - deltaP * r_arm * unit_y};
            const pos_a = {x: pos_m.x + r_arm * unit_x, y: pos_m.y + r_arm * unit_y};
            const pos_b = {x: pos_m.x - r_arm * unit_x, y: pos_m.y - r_arm * unit_y};
            const pos_d = {x: pos_m.x + d * unit_x, y: pos_m.y + d * unit_y};

            // Velocities
            const vec_a = {x: pos_a.x - pos_cm.x, y: pos_a.y - pos_cm.y};
            const vel_rot_a = {x: - omega_rot * vec_a.y, y: omega_rot * vec_a.x};
            const vel_a = {x: vel_cm.x + vel_rot_a.x, y: vel_cm.y + vel_rot_a.y};
            const vec_b = {x: pos_b.x - pos_cm.x, y: pos_b.y - pos_cm.y};
            const vel_rot_b = {x: - omega_rot * vec_b.y, y: omega_rot * vec_b.x};
            const vel_b = {x: vel_cm.x + vel_rot_b.x, y: vel_cm.y + vel_rot_b.y};
            const vec_d = {x: pos_d.x - pos_cm.x, y: pos_d.y - pos_cm.y};
            const vel_rot_d = {x: - omega_rot * vec_d.y, y: omega_rot * vec_d.x};
            const vel_d = {x: vel_cm.x + vel_rot_d.x, y: vel_cm.y + vel_rot_d.y};

            // Distances from Cm
            const d_a = Math.sqrt(vec_a.x**2 + vec_a.y**2);
            const d_b = Math.sqrt(vec_b.x**2 + vec_b.y**2);
            const d_d = Math.sqrt(vec_d.x**2 + vec_d.y**2);

            // Zoom center
            const zoom_choice = document.getElementById('zoom_center').value;
            if (zoom_choice === 'earth') center = {x: 0, y: 0};
            else if (zoom_choice === 'moon') center = moon_pos;
            else if (zoom_choice === 'midpoint') center = {x: moon_pos.x / 2, y: moon_pos.y / 2};
            else center = pos_cm;

            // Clear
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(scale, scale);
            ctx.translate(-center.x, -center.y);

            // Gray line to Moon
            ctx.strokeStyle = 'gray';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(moon_pos.x, moon_pos.y);
            ctx.stroke();

            // Yellow arrow to Sun (up)
            ctx.strokeStyle = 'yellow';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, arrow_length);
            ctx.stroke();
            drawArrow({x: 0, y: 0}, {x: 0, y: arrow_length});

            // Orange arrow to Mars
            ctx.strokeStyle = 'orange';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(arrow_length * Math.cos(mars_angle), arrow_length * Math.sin(mars_angle));
            ctx.stroke();
            drawArrow({x: 0, y: 0}, {x: arrow_length * Math.cos(mars_angle), y: arrow_length * Math.sin(mars_angle)});

            // Earth
            const earth_rotation = 2 * Math.PI * sim_time / sidereal_day;
            ctx.fillStyle = 'darkblue';
            ctx.beginPath();
            ctx.arc(0, 0, R_earth, 0, 2 * Math.PI);
            ctx.fill();

            // Continents
            ctx.fillStyle = 'green';
            continents.forEach(cont => {
                ctx.beginPath();
                cont.forEach((p, i) => {
                    const lat_rad = p.lat * Math.PI / 180;
                    const lon_rad = p.lon * Math.PI / 180 + earth_rotation;
                    const r_proj = R_earth * Math.cos(lat_rad);
                    const ex = r_proj * Math.cos(lon_rad);
                    const ey = r_proj * Math.sin(lon_rad);
                    if (i === 0) ctx.moveTo(ex, ey);
                    else ctx.lineTo(ex, ey);
                });
                ctx.closePath();
                ctx.fill();
            });

            // Lat long Earth
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1 / scale;
            for (let l = 10; l < 90; l += 10) {
                const r = R_earth * Math.cos(l * Math.PI / 180);
                ctx.beginPath();
                ctx.arc(0, 0, r, 0, 2 * Math.PI);
                ctx.stroke();
            }
            for (let i = 0; i < 36; i++) {
                const theta = (i * 10 * Math.PI / 180) + earth_rotation;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(R_earth * Math.cos(theta), R_earth * Math.sin(theta));
                ctx.stroke();
            }

            // Yellow dots
            ctx.fillStyle = 'yellow';
            const boca_theta = (boca_lon * Math.PI / 180 + earth_rotation);
            const cape_theta = (cape_lon * Math.PI / 180 + earth_rotation);
            ctx.beginPath();
            ctx.arc(R_earth * Math.cos(boca_theta), R_earth * Math.sin(boca_theta), 100000, 0, 2 * Math.PI);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(R_earth * Math.cos(cape_theta), R_earth * Math.sin(cape_theta), 100000, 0, 2 * Math.PI);
            ctx.fill();

            // Moon
            ctx.fillStyle = 'gray';
            ctx.beginPath();
            ctx.arc(moon_pos.x, moon_pos.y, R_moon, 0, 2 * Math.PI);
            ctx.fill();

            // Lat long Moon
            const moon_facing = Math.atan2(moon_pos.y, moon_pos.x) + Math.PI;
            ctx.strokeStyle = 'white';
            for (let l = 10; l < 90; l += 10) {
                const r = R_moon * Math.cos(l * Math.PI / 180);
                ctx.beginPath();
                ctx.arc(moon_pos.x, moon_pos.y, r, 0, 2 * Math.PI);
                ctx.stroke();
            }
            for (let i = 0; i < 36; i++) {
                const theta = (i * 10 * Math.PI / 180) + moon_facing;
                ctx.beginPath();
                ctx.moveTo(moon_pos.x, moon_pos.y);
                ctx.lineTo(moon_pos.x + R_moon * Math.cos(theta), moon_pos.y + R_moon * Math.sin(theta));
                ctx.stroke();
            }

            // Rotovator tether
            ctx.strokeStyle = 'white';
            ctx.beginPath();
            ctx.moveTo(pos_a.x, pos_a.y);
            ctx.lineTo(pos_b.x, pos_b.y);
            ctx.stroke();

            // Labels
            ctx.fillStyle = 'white';
            ctx.font = 'bold 200000px Arial';
            ctx.fillText('A', pos_a.x, pos_a.y);
            ctx.fillText('B', pos_b.x, pos_b.y);
            ctx.fillText('M', pos_m.x, pos_m.y);
            ctx.fillText('Cm', pos_cm.x, pos_cm.y);
            ctx.fillText('D', pos_d.x, pos_d.y);

            // Starships caricature oriented 90 to AB
            ctx.fillStyle = 'silver';
            // For A
            const dir_a_x = unit_x;
            const dir_a_y = unit_y;
            const perp_a_x = -dir_a_y;
            const perp_a_y = dir_a_x;
            // Oriented 90, nose along perp
            ctx.beginPath();
            ctx.moveTo(pos_a.x + ship_size * perp_a_x, pos_a.y + ship_size * perp_a_y);
            ctx.lineTo(pos_a.x - ship_size / 2 * dir_a_x, pos_a.y - ship_size / 2 * dir_a_y);
            ctx.lineTo(pos_a.x + ship_size / 2 * dir_a_x, pos_a.y + ship_size / 2 * dir_a_y);
            ctx.closePath();
            ctx.fill();
            // For B
            const dir_b_x = -unit_x;
            const dir_b_y = -unit_y;
            const perp_b_x = -dir_b_y;
            const perp_b_y = dir_b_x;
            ctx.beginPath();
            ctx.moveTo(pos_b.x + ship_size * perp_b_x, pos_b.y + ship_size * perp_b_y);
            ctx.lineTo(pos_b.x - ship_size / 2 * dir_b_x, pos_b.y - ship_size / 2 * dir_b_y);
            ctx.lineTo(pos_b.x + ship_size / 2 * dir_b_x, pos_b.y + ship_size / 2 * dir_b_y);
            ctx.closePath();
            ctx.fill();

            // Orbits
            orbits_list.forEach(orb => {
                if (visibility[orb.name]) {
                    const r = R_earth + orb.h;
                    ctx.strokeStyle = orb.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, r, 0, 2 * Math.PI);
                    ctx.stroke();
                    const omega = Math.sqrt(GM_earth / r**3);
                    const theta = omega * sim_time;
                    const dot_x = r * Math.cos(theta);
                    const dot_y = r * Math.sin(theta);
                    ctx.fillStyle = orb.color;
                    ctx.beginPath();
                    ctx.arc(dot_x, dot_y, 20000, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });

            // Trajectories
            trajectories_list.forEach(traj => {
                if (visibility[traj.name]) {
                    const orbits_count = parseFloat(document.getElementById(`orbits_${traj.name}`).value) || 4;
                    const arrow_minutes = parseFloat(document.getElementById(`arrow_${traj.name}`).value) || 10;
                    let release_pos, release_vel;
                    if (traj.point === 'A') { release_pos = pos_a; release_vel = vel_a; }
                    else if (traj.point === 'B') { release_pos = pos_b; release_vel = vel_b; }
                    else { release_pos = pos_d; release_vel = vel_d; }
                    const traj_data = computeTrajectory(release_pos, release_vel, orbits_count, arrow_minutes);
                    ctx.strokeStyle = traj_data.color;
                    ctx.beginPath();
                    ctx.moveTo(traj_data.points[0].x, traj_data.points[0].y);
                    for (let p of traj_data.points) {
                        ctx.lineTo(p.x, p.y);
                    }
                    ctx.stroke();

                    // Arrows
                    const dt = 10;
                    const arrow_step = Math.round(traj_data.arrow_time / dt);
                    if (arrow_step > 0) {
                        for (let j = arrow_step; j < traj_data.points.length - 1; j += arrow_step) {
                            const idx = j;
                            const from = traj_data.points[idx];
                            const next = traj_data.points[Math.min(idx + 1, traj_data.points.length - 1)];
                            const prev = traj_data.points[Math.max(idx - 1, 0)];
                            const dx = next.x - prev.x;
                            const dy = next.y - prev.y;
                            const len = Math.sqrt(dx**2 + dy**2);
                            if (len === 0) continue;
                            const udx = dx / len;
                            const udy = dy / len;
                            const to = {x: from.x + arrow_size * udx, y: from.y + arrow_size * udy};
                            ctx.strokeStyle = traj_data.color;
                            drawArrow(from, to);
                        }
                    }

                    if (traj_data.collided) {
                        ctx.fillStyle = 'red';
                        ctx.beginPath();
                        ctx.arc(traj_data.collision_pos.x, traj_data.collision_pos.y, 20000, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillStyle = 'white';
                        ctx.font = '2000000000px Arial';
                        const vh = (traj_data.collision_vel.vx / 1000).toFixed(2);
                        const vv = (traj_data.collision_vel.vy / 1000).toFixed(2);
                        ctx.fillText(`H: ${vh} km/s, V: ${vv} km/s`, traj_data.collision_pos.x, traj_data.collision_pos.y - 200000);
                    }
                }
            });

            ctx.restore();

            // Arched text
            const elapsed = (now / 1000) - start_time;
            if (elapsed < 2) {
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.fillStyle = 'white';
                ctx.font = '30px Arial';
                drawArchedText('Written by Grok and Elden Crom', 0, 0, 200);
                ctx.restore();
            } else {
                introDiv.style.display = 'none';
            }

            // Info overlays on canvas
            info_overlays = [];
            info_list.forEach(info => {
                if (visibility[info.name]) {
                    let pos, lines = [];
                    if (info.point === 'A') pos = pos_a;
                    else if (info.point === 'B') pos = pos_b;
                    else if (info.point === 'Cm') pos = pos_cm;
                    else if (info.point === 'D') pos = pos_d;
                    const {sx, sy} = getScreenPos(pos.x, pos.y);
                    const r = Math.sqrt(pos.x**2 + pos.y**2);
                    const alt = (r - R_earth) / 1000;
                    const earth_g = (GM_earth / r**2) / g0;
                    if (info.point === 'Cm') {
                        const orb_v = Math.sqrt(vel_cm.x**2 + vel_cm.y**2) / 1000;
                        const tensile_a = (m_a * omega_rot**2 * d_a) / 1e6;
                        lines = [
                            `Orbital V: ${orb_v.toFixed(2)} km/s`,
                            `Tensile to A: ${tensile_a.toFixed(2)} MN`
                        ];
                    } else {
                        let dist_cm, v_wrt_cm, vel, radial_g;
                        if (info.point === 'A') {
                            dist_cm = d_a;
                            v_wrt_cm = Math.sqrt(vel_rot_a.x**2 + vel_rot_a.y**2) / 1000;
                            vel = vel_a;
                        } else if (info.point === 'B') {
                            dist_cm = d_b;
                            v_wrt_cm = Math.sqrt(vel_rot_b.x**2 + vel_rot_b.y**2) / 1000;
                            vel = vel_b;
                        } else if (info.point === 'D') {
                            dist_cm = d_d;
                            v_wrt_cm = Math.sqrt(vel_rot_d.x**2 + vel_rot_d.y**2) / 1000;
                            vel = vel_d;
                        }
                        radial_g = (omega_rot**2 * dist_cm) / g0;
                        const total_g = earth_g + radial_g;
                        const v_wrt_earth = Math.sqrt(vel.x**2 + vel.y**2) / 1000;
                        const v_wrt_moon = Math.sqrt((vel.x - moon_vel.x)**2 + (vel.y - moon_vel.y)**2) / 1000;
                        lines = [
                            `Radial G: ${radial_g.toFixed(2)}`,
                            `Total G: ${total_g.toFixed(2)}`,
                            `Altitude: ${alt.toFixed(0)} km`,
                            `V wrt Cm: ${v_wrt_cm.toFixed(2)} km/s`,
                            `V wrt Earth: ${v_wrt_earth.toFixed(2)} km/s`,
                            `V wrt Moon: ${v_wrt_moon.toFixed(2)} km/s`
                        ];
                    }
                    info_overlays.push({lines, sx, sy});
                }
            });

            // Draw info overlays
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            info_overlays.forEach(ov => {
                ov.lines.forEach((line, i) => {
                    ctx.fillText(line, ov.sx + 10, ov.sy + 10 + i * 15);
                });
            });

            // Numerical displays
            let abd_html = '<b>A, B, D Characteristics:</b><br>';
            const points = {A: {pos: pos_a, dist_cm: d_a, vel_rot: vel_rot_a, vel: vel_a},
                            B: {pos: pos_b, dist_cm: d_b, vel_rot: vel_rot_b, vel: vel_b},
                            D: {pos: pos_d, dist_cm: d_d, vel_rot: vel_rot_d, vel: vel_d}};
            ['A', 'B', 'D'].forEach(p => {
                const point = points[p];
                const r = Math.sqrt(point.pos.x**2 + point.pos.y**2);
                const radial_g = (omega_rot**2 * point.dist_cm) / g0;
                const earth_g = (GM_earth / r**2) / g0;
                const total_g = radial_g + earth_g;
                const alt = (r - R_earth) / 1000;
                const v_wrt_c = Math.sqrt(point.vel_rot.x**2 + point.vel_rot.y**2) / 1000;
                const v_wrt_earth = Math.sqrt(point.vel.x**2 + point.vel.y**2) / 1000;
                const v_wrt_moon = Math.sqrt((point.vel.x - moon_vel.x)**2 + (point.vel.y - moon_vel.y)**2) / 1000;
                abd_html += `<br><b>${p}:</b><br>Radial G: ${radial_g.toFixed(2)}<br>Total G: ${total_g.toFixed(2)}<br>Altitude: ${alt.toFixed(0)} km<br>V wrt Cm: ${v_wrt_c.toFixed(2)} km/s<br>V wrt Earth: ${v_wrt_earth.toFixed(2)} km/s<br>V wrt Moon: ${v_wrt_moon.toFixed(2)} km/s`;
            });
            const orb_v = Math.sqrt(vel_cm.x**2 + vel_cm.y**2) / 1000;
            const tensile_a = (m_a * omega_rot**2 * d_a) / 1e6;
            const c_html = `<br><b>Cm Characteristics:</b><br>Orbital V: ${orb_v.toFixed(2)} km/s<br>Tensile Force to A: ${tensile_a.toFixed(2)} MN`;
            displaysDiv.innerHTML = abd_html + c_html;

            // Default scale
            if (scale === 1) {
                const view_radius = r_cm + 2 * r_arm;
                scale = Math.min(canvas.width, canvas.height) / (2 * view_radius * 1.1);
            }

            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);
    </script>
</body>
</html>
